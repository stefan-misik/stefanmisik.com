<?php

require_once(dirname(__FILE__) . "/../post_source.php");
require_once(dirname(__FILE__) . "/file_format.php");

class FilePostSource implements IPostSource
{
    const META_LINE_MAX_LENGTH = 4096;
    const MAX_RECORDS_IN_SINGLE_QUERY = 10000;

    /**
     * @brief Prefix for the post file names
     *
     * @var string
     */
    private $post_file_prefix = "";

    /**
     * @brief Array of post records generated by this request
     *
     * @var array
     */
    private $posts;

    /**
     * @brief Posts iteration position
     *
     * @var int
     */
    private $posts_position;

    /**
     * @brief Object for working with post files
     *
     * @var FileFormat
     */
    private $file_format;

    public function __construct(string $post_file_prefix)
    {
        $this->file_format = new FileFormat();
        $this->post_file_prefix = $post_file_prefix;
    }

    /** @copydoc IPostSource::querySource() */
    public function querySource(array $param): bool
    {
        $this->posts = array();
        $this->posts_position = 0;

        foreach($this->getSlugs($param) as $slug)
        {
            if ($post = $this->file_format->tryToLoadPost(
                    $this->getPostFilename($slug),
                    self::getParamOrDefault($param, "metaonly")))
            {
                $post["slug"] = $slug;
                if (self::filterPost($post, $param))
                {
                    $this->posts[] = $post;
                }
            }
        }
        $this->sortPosts($param);
        $this->checkLimit($param);
        return count($this->posts) > 0;
    }

    /** @copydoc IPostSource::getNextPost() */
    public function getNextPost(): ?array
    {
        $post_record = NULL;

        if ($this->posts_position < count($this->posts))
        {
            $post_record = $this->posts[$this->posts_position];
            $this->posts_position ++;
        }
        return $post_record;
    }

    /** @copydoc IPostSource::countResults() */
    public function countResults(): int
    {
        return count($this->posts);
    }

    /**
     * @brief Get the name of the post file from post slug
     *
     * @param $slug Post slug
     *
     * @return Filename of the file containing the post
     */
    public function getPostFilename(string $slug): string
    {
        return $this->post_file_prefix . $slug . "." . POST_EXT;
    }


    /*========================================================================
                                 Private Methods
      ========================================================================*/

    /**
     * @brief Get a value of a query parameter or its default
     *
     * @param $param Parameter array
     * @param $key Parameter name
     *
     * @return Evaluated value
     */
    private static function getParamOrDefault(array $param, string $key)
    {
        if (array_key_exists($key, $param))
        {
            return $param[$key];
        }
        else
        {
            switch ($key)
            {
                case "hidden": return FALSE;
                case "metaonly": return FALSE;
                case "limit": return self::MAX_RECORDS_IN_SINGLE_QUERY;
                default: return NULL;
            }
        }
    }

    /**
     * @brief Check whether given post matches parameters
     *
     * @param $record Post record to examine
     * @param $param Query parameters to check against
     *
     * @return @c TRUE if post matches given query
     */
    private static function filterPost(array $record, array $param): bool
    {
        $matches = TRUE;

        if (isset($param["tag"]))
        {
            $matches = $matches &&
                array_key_exists($param["tag"], $record["tags"]);
        }

        if (isset($param["publishedbefore"]))
        {
            $matches = $matches &&
                ($record["published"] < $param["publishedbefore"]);
        }

        $matches = $matches &&
            (self::getParamOrDefault($param, "hidden") || !$record["hidden"]);

        return $matches;
    }

    /**
     * @brief Ensure the required limit
     */
    private function checkLimit(array $param): void
    {
        $this->posts = array_slice($this->posts, 0,
            self::getParamOrDefault($param, "limit"));
    }

    /**
     * @brief Sort the loaded posts based on the query parameters
     *
     * @param $param Query parameters to check against
     */
    private function sortPosts(array $param): void
    {
        if (array_key_exists("sortfrom", $param))
        {
            switch ($param["sortfrom"])
            {
            case "oldest":
                $sort_fn = static function (array $a, array $b)
                {
                    return $a["updated"] - $b["updated"];
                };
                break;

            case "newest":
                $sort_fn = static function (array $a, array $b)
                {
                    return $b["updated"] - $a["updated"];
                };
                break;

            default:
                $sort_fn = static function (array $a, array $b)
                {
                    return 0;
                };
                break;
            }
            usort($this->posts, $sort_fn);
        }
    }

    /**
     * @brief Generate the list of slugs to consider
     *
     * @param $param Parameters passed to query
     *
     * @return The array of post slugs to consider
     */
    private function getSlugs(array $param): array
    {
        $slugs = array();
        if (array_key_exists("slug", $param))
        {
            if (file_exists($this->getPostFilename($param["slug"])))
            {
                $slugs = array($param["slug"]);
            }
        }
        else
        {
            $slugs = array_values(preg_filter(
                    "/^(" . SLUG_PATTERN . ")\." . POST_EXT . "$/",
                    "$1",
                    scandir($this->post_file_prefix)));
        }
        return $slugs;
    }
}

